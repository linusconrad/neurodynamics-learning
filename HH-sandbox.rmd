---
title: "Hodgkin Huxely sandbox"
output: 
  html_notebook: 
    number_sections: yes
---

```{r setup, include=FALSE}
linewidth = 6            # set this as default width for figs, change it so its identical to
                            # the linewidth of your doc (in inch)
knitr::opts_chunk$set(
  echo = TRUE,              # print all code
  dev = "png",              # use png images for export
  warning = FALSE,          # suppress warnings
  fig.path = "./figure/" ,  # place the png images in this folder
  fig.width = linewidth,
  message = FALSE,          # supress messages
  dpi = 600,                # high quality output
  cache = T                 # speed up compilation by only running changed chunks
  )
# prepare you R environment
library(tidyverse)          # the backbone
library(ggpubr)             # plots and mulitpanel
library(rstatix)            # tidy stat tests
library(ggthemes)           # nicer defaults for ggplot
library(kableExtra)         # nice table printing in latex

library(reticulate)         # support for python
# the environment we have been using
use_condaenv(condaenv = "brian", conda = "auto", required = FALSE)

plot.font = "Palatino"      # set this as a shorthand

# make a default setting for ggplot
theme_set(
  theme_few() +
    theme(
      legend.position = "bottom",
      legend.title = NULL,
      strip.placement = "outside",
      strip.background = element_blank(),
      #          plot.margin = margin(t = 0.2,r =0.1, b = 0, l = 0, "cm"),
      text = element_text(
        family = plot.font,
        size = 11,
        face = "plain"
      ),
      title = element_text(family = plot.font),
      strip.text = element_text(family = plot.font)
    )
)
```

Import the libraries used.
```{python}
# Import brian
from brian2 import *
# data frame support and `tidy` plotting
import pandas as pd
import numpy as np
import seaborn as sns

# Assign some tidier functions for the outputs generated by brian.
def tidy_spike(s_mon_object) :
    """
    This function takes all the data from within a spikemonitor brian object
    and makes it into a tidy pandas frame
    """
    # extract the data to a wide frame
    sdata_wide =  pd.DataFrame.from_dict(s_mon_object.all_values()['t'],orient = 'index')
    sdata_wide.index.name = 'neuron'
    sdata_wide.reset_index(inplace=True)
    # there will be now 1 neuron column with number of neuron rows
    # and a column for each spike (as many columns as the maximum number of spikes for a neuron)
    # there is an index column and a neuron column, so the max number of spikes
    # and the number of data colums is the number of columns -2
    spike_max = sdata_wide.shape[1]
    
    # pivot longer by neuron
    sdata_long = sdata_wide.melt(id_vars = ('neuron'),
                               value_vars = list(range(0,spike_max-1)),
                               var_name = 'spikeno',
                               value_name = 't')
    
    # tidy and update the thing
    sdata_long = sdata_long.sort_values(['neuron', 'spikeno'])
    # drop NA values
    sdata_long = sdata_long.dropna()
    # add a proper numeric time variable
    sdata_long['t_ms'] = sdata_long['t'].apply(lambda x: x/ms)
    
    #return the thing
    return(sdata_long)
    
# Make a tidier for by neuron summaries
def tidy_byN(aneuron, monitorobj):
    """
    This function takes a brian neuron group
    and a spike monitor object of it
    then returns a tidy pandas frame of the start and and values and the firing rates
    """
    # extracts all the model starting parameters and the last timepoint
    byN = aneuron.get_states(units=False, format='pandas')
    
    # duration of the run
    run_dur = byN['t_in_timesteps'][0]*byN['dt'][0]
    # now we can assign the firing rate data as new columns
    byN['nAP'] = pd.Series(np.array(monitorobj.count))
    # calculate firing rate
    byN = byN.assign(FRate_hz = byN['nAP']/run_dur)
    return(byN)

def tidy_v(ts_statemon):
    '''
    Function that will return a tidy timeseries dataframe
    from a brian StateMon object.
    '''
    # start over with a wide frame
    ts_frame = pd.DataFrame(ts_statemon.v)
    
    # the number of rows is the number of neurons
    n_neuron = ts_statemon.v.shape[0]
    
    # make long with 1 Neuron as 1 column
    ts_frame = ts_frame.transpose()
    # add the time axis
    ts_frame.index.name = 't_dummy'
    ts_frame['t'] = pd.Series(np.array(ts_statemon.t))
    # this does the job
    return(pd.melt(ts_frame,
                   value_vars = list(range(0, n_neuron)),
                   id_vars = ['t'],
                   var_name = "neuron",
                   value_name = 'v'))

```

First, I would like to get to grips with running simulations.
I tried yesterday with some code that should have worked but did not.
What needss to be done is the following:

1. Assign a HH model make it so that it has multiple neurons and parametrise it. no need for synapses.
2. Run it with current set to different values (ie current clamp it).
Record, tidy and plot the data.

Get started with assigning input variables.
```{python}
# Parameters
area = 20000*umetre**2              # Membrane area
Cm = 1*ufarad*cm**-2 * area         # capacitance per area
gl = 5e-5*siemens*cm**-2 * area     # leak conductance per area
El = -65*mV                         # leak reversal (RMP)
EK = -90*mV                         # potassium reversal
ENa = 50*mV                         # sodium reversal
g_na = 100*msiemens*cm**-2 * area   # Na conductance per area
g_kd = 30*msiemens*cm**-2 * area    # K conductance per area 
VT = -63*mV                         # nernst slope
N = 3                               # Numer of neurons in the group
I_sim = linspace(1, 50, N)*nA
eqs_HH_3 = '''
# Voltage equation
dv/dt = (gl*(El-v) - g_na*(m*m*m)*h*(v-ENa) - g_kd*(n*n*n*n)*(v-EK) + I)/C : volt
# Na activation particle
dm/dt = 0.32*(mV**-1)*(13.*mV-v+VT)/
    (exp((13.*mV-v+VT)/(4.*mV))-1.)/ms*(1-m)-0.28*(mV**-1)*(v-VT-40.*mV)/
    (exp((v-VT-40.*mV)/(5.*mV))-1.)/ms*m : 1
# K activation particle
dn/dt = 0.032*(mV**-1)*(15.*mV-v+VT)/
    (exp((15.*mV-v+VT)/(5.*mV))-1.)/ms*(1.-n)-.5*exp((10.*mV-v+VT)/(40.*mV))/ms*n : 1
# Na inactivation particle
dh/dt = 0.128*exp((17.*mV-v+VT)/(18.*mV))/ms*(1.-h)-4./(1+exp((40.*mV-v+VT)/(5.*mV)))/ms*h : 1

I : amp (shared) # This is necessary so each neuron has the same current injection
C : farad
'''
# Create the neuron group
# In this example everything is kept constant, but there is 3 neurons with different capacitance
group = NeuronGroup(N, eqs_HH_3,
                    threshold='v > -40*mV',
                    refractory='v > -40*mV',
                    method='exponential_euler')
group.v = El
#agroup.I = I
#assign the capacitances
group.C = array([0.8, 1, 1.2])*ufarad*cm**-2*area
statemon = StateMonitor(group, 'v', record=True)

```





































