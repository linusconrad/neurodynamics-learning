# ---
# jupyter:
#   jupytext:
#     formats: ipynb,Rmd,py:hydrogen
#     text_representation:
#       extension: .py
#       format_name: hydrogen
#       format_version: '1.3'
#       jupytext_version: 1.4.2
#   kernelspec:
#     display_name: Python 3
#     language: python
#     name: python3
# ---

# %% [markdown]
# # Hodgkin Huxeley sandbox
#
# The aim to learn is to make HH models with many neurons.
# These are to be parametrised with different current desities.
# Once setup such a model can be used to probe corellated channel expression.
#
# First I want to be familiar with brian enough to do the following tasks:
#
# 1. Generate HH models with parametrised neurons
# 2. Run simulations with them that are similar to lab ephys settings (CC steps, VC steps, I/O curves)
#
# After accomplishing this:
#
# 1. Research sane input parameters/model equations for a simple neuron with ~3-4 conductances (see Balachandar)
# 2. Create a neuron model and parametrise it with bivariate, correlated current densities
# 3. Run simulations and prepare scripts that deal with the output
#
# Such scripts will essentially do the same task as the scripts I would need to analyse real data, so we are killing two birds with one stone here.
#

# %%
# Setup the environment
# Import brian
from brian2 import *
# data frame support and `tidy` plotting
import pandas as pd
import numpy as np
from scipy import signal
import seaborn as sns

# Assign some tidier functions for the outputs generated by brian.
def tidy_spike(s_mon_object) :
    """
    This function takes all the data from within a spikemonitor brian object
    and makes it into a tidy pandas frame
    """
    # extract the data to a wide frame
    sdata_wide =  pd.DataFrame.from_dict(s_mon_object.all_values()['t'],orient = 'index')
    sdata_wide.index.name = 'neuron'
    sdata_wide.reset_index(inplace=True)
    # there will be now 1 neuron column with number of neuron rows
    # and a column for each spike (as many columns as the maximum number of spikes for a neuron)
    # there is an index column and a neuron column, so the max number of spikes
    # and the number of data colums is the number of columns -2
    spike_max = sdata_wide.shape[1]
    
    # pivot longer by neuron
    sdata_long = sdata_wide.melt(id_vars = ('neuron'),
                               value_vars = list(range(0,spike_max-1)),
                               var_name = 'spikeno',
                               value_name = 't')
    
    # tidy and update the thing
    sdata_long = sdata_long.sort_values(['neuron', 'spikeno'])
    # drop NA values
    sdata_long = sdata_long.dropna()
    # add a proper numeric time variable
    sdata_long['t_ms'] = sdata_long['t'].apply(lambda x: x/ms)
    
    #return the thing
    return(sdata_long)
    
# Make a tidier for by neuron summaries
def tidy_byN(aneuron, monitorobj):
    """
    This function takes a brian neuron group
    and a spike monitor object of it
    then returns a tidy pandas frame of the start and and values and the firing rates
    """
    # extracts all the model starting parameters and the last timepoint
    byN = aneuron.get_states(units=False, format='pandas')
    
    # duration of the run
    run_dur = byN['t_in_timesteps'][0]*byN['dt'][0]
    # now we can assign the firing rate data as new columns
    byN['nAP'] = pd.Series(np.array(monitorobj.count))
    # calculate firing rate
    byN = byN.assign(FRate_hz = byN['nAP']/run_dur)
    return(byN)

def tidy_v(ts_statemon):
    '''
    Function that will return a tidy timeseries dataframe
    from a brian StateMonitor object containing timeseries.
    '''
    # start over with a wide frame
    ts_frame = pd.DataFrame(ts_statemon.v)
    
    # the number of rows is the number of neurons
    n_neuron = ts_statemon.v.shape[0]
    
    # make long with 1 Neuron as 1 column
    ts_frame = ts_frame.transpose()
    # add the time axis
    ts_frame.index.name = 't_dummy'
    ts_frame['t'] = pd.Series(np.array(ts_statemon.t))
    # this does the job
    return(pd.melt(ts_frame,
                   value_vars = list(range(0, n_neuron)),
                   id_vars = ['t'],
                   var_name = "neuron",
                   value_name = 'v'))


# %% [markdown]
# # Current Clamp experiment with a parametrised neuron group
# First Task: Run a current clamp experiment and show the result.
# The following HH model is taken from the examples in the brian [introduction](https://brian2.readthedocs.io/en/stable/resources/tutorials/3-intro-to-brian-simulations.html).
#

# %%
# Parameters
area = 20000*umetre**2              # Membrane area
Cm = 1*ufarad*cm**-2 * area         # capacitance per area
gl = 5e-5*siemens*cm**-2 * area     # leak conductance per area
El = -65*mV                         # leak reversal (RMP)
EK = -90*mV                         # potassium reversal
ENa = 50*mV                         # sodium reversal
g_na = 100*msiemens*cm**-2 * area   # Na conductance per area
g_kd = 30*msiemens*cm**-2 * area    # K conductance per area 
VT = -63*mV                         # nernst slope
N = 3                               # Numer of neurons in the group
I_stim = linspace(0, 0.1, 4)*namp
eqs_HH_3 = '''
# Voltage equation
dv/dt = (gl*(El-v) - g_na*(m*m*m)*h*(v-ENa) - g_kd*(n*n*n*n)*(v-EK) + I)/C : volt
# Na activation particle
dm/dt = 0.32*(mV**-1)*(13.*mV-v+VT)/
    (exp((13.*mV-v+VT)/(4.*mV))-1.)/ms*(1-m)-0.28*(mV**-1)*(v-VT-40.*mV)/
    (exp((v-VT-40.*mV)/(5.*mV))-1.)/ms*m : 1
# K activation particle
dn/dt = 0.032*(mV**-1)*(15.*mV-v+VT)/
    (exp((15.*mV-v+VT)/(5.*mV))-1.)/ms*(1.-n)-.5*exp((10.*mV-v+VT)/(40.*mV))/ms*n : 1
# Na inactivation particle
dh/dt = 0.128*exp((17.*mV-v+VT)/(18.*mV))/ms*(1.-h)-4./(1+exp((40.*mV-v+VT)/(5.*mV)))/ms*h : 1

I : amp (shared) # This is necessary so each neuron has the same current injection
C : farad
'''
# Create the neuron group
# In this example everything is kept constant, but there is 3 neurons with different capacitance
group = NeuronGroup(N, eqs_HH_3,
                    #threshold='v > -40*mV',
                    #refractory='v > -40*mV',
                    method='exponential_euler')

# Start the simulation at resting potential
group.v = El
group.I = 0*namp # start with no stimulation
#assign the capacitances
group.C = array([0.8, 1, 1.2])*ufarad*cm**-2*area
statemon = StateMonitor(group, 'v', record=True)

# store the initial state of the simulation
groupnet = Network(group,statemon)
groupnet.store()

# %%
start_scope()
# Run the simulation
# make an empty list for the results
capresult = []
# time for each sweep (ms)
runtime = 50
for I in I_stim:
    # restore the system
    groupnet.restore()
    # set the new stimulation current
    group.I = I
    groupnet.run(runtime*ms)
    runresult = tidy_v(statemon)
    # write the stimulation current and time by sweep
    runresult['sweep'] = [I/namp] * len(runresult['v'])
    rowperneuron = int(len(runresult['v'])/N) # this needs to an integer
    runresult['t_stim'] = tile(np.linspace(0,runtime, rowperneuron), N) # need to add n neurons here
    capresult.append(runresult)

# %%
#tidy and plot
capresult = pd.concat(capresult)

# %%
sns.relplot(x = 't_stim',
            y = 'v',
            kind = 'line',
            #hue = 'sweep',
            row = 'sweep',
            height = 2,
            aspect = 8,
            #row = 'neuron',
            hue = 'neuron',
            data = capresult)

# %% [markdown]
# I played with the stimulation voltage, it seems like spikes mostly go to full 50 mV amplitude with the given conductances even for small injections.
#
# That is encouraging, the output is tidy, now we can try to include the per-neuron parameters, to summarise more.
#
# We can do this with a spikemonitor object.

# %%
start_scope()
# re-assign the group
group = NeuronGroup(N, eqs_HH_3,
                    threshold='v > 45*mV', # Set this to a high value, I like the spiketime to be more with the peak!
                    refractory='v > 0*mV',
                    method='exponential_euler')

# Start the simulation at resting potential
group.v = El
group.I = 0*namp # start with no stimulation
#assign the capacitances
group.C = array([0.8, 1, 1.2])*ufarad*cm**-2*area
statemon = StateMonitor(group, 'v', record=True)
spikemon = SpikeMonitor(group, variables='v')

# store the initial state of the simulation
groupnet = Network(group,statemon, spikemon)
groupnet.store()

# Run the simulation now instead tidy the per neuron sumamry
# make an empty list for the results

# renew the I iterator so we can manipulate it closer to where it takes effect
I_stim = linspace(0, 4, 4)*namp

tsresult = []       # container for the timeseries result
summaryresult = []  # container for the per-neuron summaries
# time for each sweep (ms)
runtime = 50
for I in I_stim:
    # restore the system
    groupnet.restore()
    # set the new stimulation current and run
    group.I = I
    groupnet.run(runtime*ms)
      
    # tidy and save the time series results
    runresult = tidy_v(statemon)
    runresult['sweep'] = [I/namp] * len(runresult['v'])
    rowperneuron = int(len(runresult['v'])/N) # this needs to an integer
    runresult['t_stim'] = tile(np.linspace(0,runtime, rowperneuron), N) # need to add n neurons here
    tsresult.append(runresult)
    
    # tidy and save the summary results
    runsummary = tidy_byN(group, spikemon)
    summaryresult.append(runsummary)
    

# %%
#tidy and plot
tsresult = pd.concat(tsresult)
summaryresult = pd.concat(summaryresult)

# %% [markdown]
# This plot will show the firing rate dependent on capacitance for every stimulation.

# %%
sns.relplot(data = summaryresult,
           x = "C",
           y = "FRate_hz",
           col = "I")

# %% [markdown]
# Next one will show the timecourses.

# %%
sns.relplot(x = 't_stim',
            y = 'v',
            kind = 'line',
            #hue = 'sweep',
            row = 'sweep',
            height = 2,
            aspect = 8,
            #row = 'neuron',
            hue = 'neuron',
            data = tsresult)

# %% [markdown]
# Next, make it more complex and sample a larger range of C to get a more continous response curve.
# To do this we vary C systematically in 100 neurons.

# %%
start_scope()
# re-assign the group
N = 100
group = NeuronGroup(N, eqs_HH_3,
                    threshold='v > -40*mV',
                    refractory='v > -40*mV',
                    method='exponential_euler')

# Start the simulation at resting potential
group.v = El
group.I = 0*namp # start with no stimulation
# assign the capacitances
group.C = np.linspace(0.2,1.5,N)*ufarad*cm**-2*area
statemon = StateMonitor(group, 'v', record=True)
spikemon = SpikeMonitor(group, variables='v')

# store the initial state of the simulation
groupnet = Network(group,statemon, spikemon)
groupnet.store()

# %%
# rerassing the stimulus protocol so its easier to manipulate
I_stim = linspace(0.1, 20, 20)*namp

tsresult = []       # container for the timeseries result
spikeresult = []    # container for the spikes
summaryresult = []  # container for the per-neuron summaries
# time for each sweep (ms)
runtime = 300
for I in I_stim:
    # restore the system
    groupnet.restore()
    # set the new stimulation current and run
    group.I = I
    groupnet.run(runtime*ms)
      
    # tidy and save the time series results
    #runresult = tidy_v(statemon)
    #runresult['sweep'] = [I/namp] * len(runresult['v'])
    #rowperneuron = int(len(runresult['v'])/N) # this needs to an integer
    #runresult['t_stim'] = tile(np.linspace(0,runtime, rowperneuron), N) # need to add n neurons here
    #tsresult.append(runresult)
    
    # tidy and save the summary results
    runsummary = tidy_byN(group, spikemon)
    # tidy and summarise the spikes
    runspikes = tidy_spike(spikemon)
    # add the injection current to the spikes
    runspikes['I'] = [I/namp] * len(runspikes['t_ms'])
    
    spikeresult.append(runspikes)
    summaryresult.append(runsummary)

# %% [markdown]
# I commented out the timeseries objects because in all likelyhood they would grow quite large.
# Now plot the continous response to capacitance.

# %%
# concarenate the results and scale to nA
summaryresult = pd.concat(summaryresult)
summaryresult['I'] = summaryresult['I']/1e-9

# %%
# concatenate the spike result
spikeresult = pd.concat(spikeresult)

# %% [markdown]
# The following shows the result of the current clamp experiment.
# Full response curves of capacitance and firing rate for different stimulation voltages.

# %%
sns.lineplot(data = summaryresult,
           x = "C",
           y = "FRate_hz",
           #kind = 'line',
           #palette="pastel",
           hue = "I")

# %%
sns.relplot(data = spikeresult,
            x = 't_ms',
            y = 'neuron',
            col = 'I',
            alpha = 0.1,
            color=".2",
            marker=".",
            #size = 0.001,
            col_wrap = 5)

# %% [markdown]
# # Voltage clamp experiment
# Without using particularly different paradigms in terms of the coding we can run voltage clamp experiments.
# Actually, there is no current equation in the model, so we need to add it.
#
# The model contained a line for the membrane potential V:
# \begin{equation}
# \frac{\partial V}{\partial t} = \frac{g_l(E_l - V) - g_{\text{Na}} m^3 h (V - E_{\text{Na}}) - g_{\text{K}} n^4 (V-E_{\text{K}}) + I}{C}
# \end{equation}
# $I$ in this case being a injected stimulation current.
#
# This is sctually just describing the effect of the time course of the membrane currents on $V$.
# Everything in the counter of the fraction is defining the currents.
#
# The above says nothing more than that $V$ depends on the sum of ionic currents divided by capacitance that needs to be charged to change it:
# \begin{equation}
# \frac{\partial V}{\partial t} = \frac{\sum{} I_{\text{channel}}}{C}
# \end{equation}
#
# Therefore, we can just take the membrane current, also split by channel if needed into our equation system.
# This is basically just Ohms law, all the time dependence lies in the equations for the gating particles.
# \begin{equation}
# I_m = g_l(E_l - V) - g_{\text{Na}} m^3 h (V - E_{\text{Na}}) - g_{\text{K}} n^4 (V-E_{\text{K}})
# \end{equation}
# Individual channel example, here sodium:
#
# \begin{equation}
# \frac{\partial I_{\text{Na}}}{\partial t} = g_{\text{Na}} m^3 h (V - E_{\text{Na}})
# \end{equation}
#
# For now we can introduce the equation above for $I_m$ and modify the voltage equation to
#
# \begin{equation}
# \frac{\partial V}{\partial t} = \frac{I_m + I}{C}
# \end{equation}

# %%
start_scope()
# re-assign the group
N = 1
# before this was -65..
El = 0*mV
eqs_HH_new = '''
# Current injected
I : amp (shared) # This is necessary so each neuron has the same current injection
# Capacitance of the membrane
C : farad
# Voltage clamp
v : volt

# Membrane current
Im = gl*(v-El) + g_na*(m*m*m)*h*(v-ENa) + g_kd*(n*n*n*n)*(v-EK): amp

# Voltage equation
#dv/dt = (Im + I)/C : volt

# Channel gating
# Na activation particle
dm/dt = 0.32*(mV**-1)*(13.*mV-v+VT)/
    (exp((13.*mV-v+VT)/(4.*mV))-1.)/ms*(1-m)-0.28*(mV**-1)*(v-VT-40.*mV)/
    (exp((v-VT-40.*mV)/(5.*mV))-1.)/ms*m : 1
# K activation particle
dn/dt = 0.032*(mV**-1)*(15.*mV-v+VT)/
    (exp((15.*mV-v+VT)/(5.*mV))-1.)/ms*(1.-n)-.5*exp((10.*mV-v+VT)/(40.*mV))/ms*n : 1
# Na inactivation particle
dh/dt = 0.128*exp((17.*mV-v+VT)/(18.*mV))/ms*(1.-h)-4./(1+exp((40.*mV-v+VT)/(5.*mV)))/ms*h : 1

'''
group = NeuronGroup(N, eqs_HH_new,
                    #threshold='v > -40*mV',
                    #refractory='v > -40*mV',
                    method='exponential_euler')

# Start the simulation at resting potential
group.v = -65*mV
group.I = 0*namp # start with no stimulation
# assign the capacitances
group.C = np.linspace(0.2,1.5,N)*ufarad*cm**-2*area
statemon = StateMonitor(group, 'Im', record=True)

# store the initial state of the simulation
# do not add the statemonitor, as before. It will just record the equilibration step.
# that will then mess up the registering
groupnet = Network(group, statemon)

# run the simulation at RMP for a bit to equilibrate
groupnet.run(100*ms)
groupnet.store()


# %%
# We need a new tidier function to get `I` from statemonitors
# Since getting the data is a method
# And I did not find a way to use wildcard methods
# We need a new tidier for every variable we might record with the monitor...

def tidy_I(ts_statemon):
    '''
    Function that will return a tidy timeseries dataframe
    from a brian StateMonitor object containing I timeseries.
    '''
    # start over with a wide frame
    ts_frame = pd.DataFrame(ts_statemon.Im)
    
    # the number of rows is the number of neurons
    n_neuron = ts_statemon.Im.shape[0]
    
    # make long with 1 Neuron as 1 column
    ts_frame = ts_frame.transpose()
    # add the time axis
    ts_frame.index.name = 't_dummy'
    ts_frame['t'] = pd.Series(np.array(ts_statemon.t))
    # this does the job
    return(pd.melt(ts_frame,
                   value_vars = list(range(0, n_neuron)),
                   id_vars = ['t'],
                   var_name = "neuron",
                   value_name = 'Im'))


# %%
# re- assign the "stimulus protocol" so its easier to manipulate
V_stim = linspace(-80, 50, 20)*mV

tsresult = []       # container for the timeseries result
summaryresult = []  # container for the per-neuron summaries
# time for each sweep (ms)
runtime = 20
for V in V_stim:
    # restore the neurons 
    groupnet.restore()
    # set the new stimulation current and run
    group.v = V
    # run the neuron with monitor
    groupnet.run(runtime*ms)
      
    # tidy and save the time series results
    runresult = tidy_I(statemon)
    runresult['sweep'] = [V/mV] * len(runresult['Im'])
    rowperneuron = int(len(runresult['Im'])/N) # this needs to an integer
    runresult['t_stim'] = tile(np.linspace(0,runtime +100, rowperneuron), N) # need to add n neurons here
    tsresult.append(runresult)
    
    # tidy and save the summary results
    #runsummary = tidy_byN(group, spikemon)
    #summaryresult.append(runsummary)

# %%
tsresult = pd.concat(tsresult)

# %% [markdown]
# Now we can do voltage clamp!

# %%
sns.relplot(data = tsresult.query('t_stim > 99 & t_stim < 110'),
            x = 't_stim',
            y = 'Im',
            hue = 'sweep',
            #col = 'sweep',
            #col_wrap = 4,
            kind = 'line')
           #facet_kws={'sharey':True, 'sharex': True})

# %% [markdown]
# ## Voltage clamp with individual Ion channels
# It would be nice to be able to see the individual currents.
# We just need to split the $I_m$ equation into its constituents.

# %%
start_scope()
# re-assign the group
N = 1
# before this was -65..
El = 0*mV

# HH equation with separate channel variable
eqs_HH_Iind = '''
##### Experimental parameters to set
# Current injection
I : amp (shared) # This is necessary so each neuron has the same current injection
# Capacitance of the membrane
C : farad
# Voltage clamp
v : volt (shared)

##### Ion channel currents
I_l = gl*(v-El) :amp
I_Na = g_na*(m*m*m)*h*(v-ENa) :amp
I_K = g_kd*(n*n*n*n)*(v-EK) :amp

###### I and V
# Current
Im = I_l + I_Na + I_K: amp

# Voltage equation (for current clamp)
#dv/dt = (Im + I)/C : volt

##### Channel kinetics
# Na activation particle
dm/dt = 0.32*(mV**-1)*(13.*mV-v+VT)/
    (exp((13.*mV-v+VT)/(4.*mV))-1.)/ms*(1-m)-0.28*(mV**-1)*(v-VT-40.*mV)/
    (exp((v-VT-40.*mV)/(5.*mV))-1.)/ms*m : 1
    
# Na inactivation particle
dh/dt = 0.128*exp((17.*mV-v+VT)/(18.*mV))/ms*(1.-h)-4./(1+exp((40.*mV-v+VT)/(5.*mV)))/ms*h : 1
    
# K activation particle
dn/dt = 0.032*(mV**-1)*(15.*mV-v+VT)/
    (exp((15.*mV-v+VT)/(5.*mV))-1.)/ms*(1.-n)-.5*exp((10.*mV-v+VT)/(40.*mV))/ms*n : 1
'''

group = NeuronGroup(N, eqs_HH_Iind,
                    #threshold='v > -40*mV',
                    #refractory='v > -40*mV',
                    method='exponential_euler')

# Start the simulation at resting potential
group.v = -65*mV
group.I = 0*namp # start with no stimulation
# assign the capacitances
group.C = np.linspace(0.2,1.5,N)*ufarad*cm**-2*area
statemon = StateMonitor(group, ['I_Na', 'I_K', 'I_l'], record=True)

# store the initial state
groupnet = Network(group, statemon)

# run the simulation at RMP for a bit to equilibrate
groupnet.run(100*ms)
groupnet.store()

# then voltage clamp for 20 ms
# restore the neurons 
groupnet.restore()
# set the new stimulation current and run
group.v = -40 *mV
# run the neuron with monitor
groupnet.run(30*ms)

# %% [markdown]
# Now we should have a statemonitor with the 3 currents.
# We need to tidy it.
# This is going to be more complex because there are more variables now.

# %%
# I just wanted to access the data as array without index etc to make a new df
# This is my ungodly solution for the content of 1 column
# This should not be so hard and I probably found a bad way of doing this
# In order this unreadable liner does:
# 1: get the data as wide array
# 2: put this data into a wide dataframe that is indexed
# 3: transpose the dataframe to wide
# 4: subset the column we want without index
pd.DataFrame(np.array(statemon.I_Na)).transpose()[0]

# %%
# now we can add those as columns to a dataframe
Iframe = pd.DataFrame({
    't': np.array(statemon.t),
    'I_Na': pd.DataFrame(np.array(statemon.I_Na)).transpose()[0],
    'I_l': pd.DataFrame(np.array(statemon.I_l)).transpose()[0],
    'I_K': pd.DataFrame(np.array(statemon.I_K)).transpose()[0]})


# %% [markdown]
# Now we can make a separate column for the total.

# %%
Iframe = Iframe.assign(I_tot = Iframe['I_l']+Iframe['I_Na']+Iframe['I_K'], inplace = True)

# %%
# melt and plot the thing
sns.lineplot(data = pd.melt(Iframe,
                            value_vars = ['I_l', 'I_Na', 'I_K', 'I_tot'],
                            id_vars = ['t']).query('t > 0.099 & t < 0.11'),
            hue = 'variable',
             x = 't',
            y = 'value')


# %% [markdown]
# # Voltage clamp with Parametrised Neurons
# Now simulate a neuron group with multiple neurons.
# It will make it more difficult to get the data out.
# Try varying the sodium conductance. 

# %%
start_scope()
# re-assign the group
#reassign all the parameters to not get confused
# Parameters
area = 20000*umetre**2              # Membrane area
Cm = 1*ufarad*cm**-2 * area         # capacitance per area
gl = 5e-5*siemens*cm**-2 * area     # leak conductance per area
El = -65*mV                         # leak reversal (RMP)
EK = -90*mV                         # potassium reversal
ENa = 50*mV                         # sodium reversal
g_na = 100*msiemens*cm**-2 * area   # Na conductance per area
g_kd = 30*msiemens*cm**-2 * area    # K conductance per area 
VT = -63*mV  
# HH equation with separate channel variable
eqs_HH_Iind = '''
##### Experimental parameters to set
# Current injection
I : amp (shared) # This is necessary so each neuron has the same current injection
# Capacitance of the membrane
C : farad
# Voltage clamp
v : volt (shared)
# Na channel density
dens_na: siemens*metre**-2

##### Ion channel currents
I_l = gl*(v-El) :amp
I_Na = (dens_na*area)*(m*m*m)*h*(v-ENa) :amp
I_K = g_kd*(n*n*n*n)*(v-EK) :amp

###### I and V
# Current
Im = I_l + I_Na + I_K: amp

# Voltage equation (for current clamp)
#dv/dt = (Im + I)/C : volt

##### Channel kinetics
# Na activation particle
dm/dt = 0.32*(mV**-1)*(13.*mV-v+VT)/
    (exp((13.*mV-v+VT)/(4.*mV))-1.)/ms*(1-m)-0.28*(mV**-1)*(v-VT-40.*mV)/
    (exp((v-VT-40.*mV)/(5.*mV))-1.)/ms*m : 1
    
# Na inactivation particle
dh/dt = 0.128*exp((17.*mV-v+VT)/(18.*mV))/ms*(1.-h)-4./(1+exp((40.*mV-v+VT)/(5.*mV)))/ms*h : 1
    
# K activation particle
dn/dt = 0.032*(mV**-1)*(15.*mV-v+VT)/
    (exp((15.*mV-v+VT)/(5.*mV))-1.)/ms*(1.-n)-.5*exp((10.*mV-v+VT)/(40.*mV))/ms*n : 1
'''
N = 5 # 5 Neurons
group = NeuronGroup(N, eqs_HH_Iind,
                    #threshold='v > -40*mV',
                    #refractory='v > -40*mV',
                    method='exponential_euler')

# Start the simulation at resting potential
group.v = -65*mV
group.I = 0*namp # start with no stimulation
# assign the conductances, here we systematically vary the Na
group.dens_na = np.linspace(0.1,200,N)*msiemens*cm**-2
statemon = StateMonitor(group, ['I_Na', 'I_K', 'I_l'], record=True)


# %%
# store the initial state of the simulation
# do not add the statemonitor, as before. It will just record the equilibration step.
# that will then mess up the registering
groupnet = Network(group, statemon)

# run the simulation at RMP for a bit to equilibrate
groupnet.run(50*ms)
groupnet.store()

# then voltage clamp for 20 ms
# restore the neurons 
groupnet.restore()
# set the new stimulation current and run
group.v = -40 *mV
# run the neuron with monitor
groupnet.run(30*ms)

# %% [markdown]
# Now try to write a tidier for this kind of object.
# Once done this can then used in a loop to run multiple instances (sweeps).

# %%
# I have no better idea then to run the ts tidier multiple times to do this
# Number of neurons
n_neuron = statemon.I_Na.shape[0]
# wide format with Neuron as column
INavariable = pd.DataFrame(statemon.I_Na).transpose()
# add time variable then melt by neuron
INavariable['t'] = pd.Series(np.array(statemon.t))
INavariable = pd.melt(INavariable,
                   value_vars = list(range(0, n_neuron)),
                   id_vars = ['t'],
                   var_name = "neuron",
                   value_name = 'I_Na')

# Melt the other currents into one column and add to the main data frame
# This produces the 1 column dataframes
Ilvariable = pd.DataFrame(statemon.I_l).transpose()
Ilvariable = pd.melt(Ilvariable,
        value_vars = list(range(0, n_neuron)),
        var_name = "neuron",
        value_name = 'I_l')

IKvariable = pd.DataFrame(statemon.I_K).transpose()
IKvariable = pd.melt(IKvariable,
        value_vars = list(range(0, n_neuron)),
        var_name = "neuron",
        value_name = 'I_K')

INavariable.assign(I_K = IKvariable['I_K'])


# %%
# Write the tidier
def tidy_HHcurrents(monobjct):
    # Number of neurons
    n_neuron = monobjct.I_Na.shape[0]
    # wide format with Neuron as column
    resultdf = pd.DataFrame(monobjct.I_Na).transpose()
    # add time variable then melt by neuron
    resultdf['t'] = pd.Series(np.array(monobjct.t))
    resultdf = pd.melt(resultdf,
                   value_vars = list(range(0, n_neuron)),
                   id_vars = ['t'],
                   var_name = "neuron",
                   value_name = 'I_Na')
    
    # create long dfs from the other variables
    Il = pd.DataFrame(monobjct.I_l).transpose()
    Il = pd.melt(Il,
        value_vars = list(range(0, n_neuron)),
        var_name = "neuron",
        value_name = 'I_l')['I_l']
    
    IK = pd.DataFrame(monobjct.I_K).transpose()
    IK = pd.melt(IK,
        value_vars = list(range(0, n_neuron)),
        var_name = "neuron",
        value_name = 'I_K')['I_K']
    
    # add the columns to the object
    resultdf = resultdf.assign(I_l = Il, I_K = IK)
    resultdf['I_tot'] = resultdf['I_Na'] + resultdf['I_l'] + resultdf['I_K']
    return(resultdf)


# %%
# filter for the relevant time points
# melt long and then plot
# melt and plot the thing
gNa_varieddf = tidy_HHcurrents(statemon)
sns.relplot(data = pd.melt(gNa_varieddf,
                            value_vars = ['I_l', 'I_Na', 'I_K', 'I_tot'],
                            id_vars = ['t', 'neuron']).query('t > 0.049 & t < 0.11'),
            col = 'neuron',
            kind = 'line',
            hue = 'variable',
            x = 't',
            y = 'value')


# %% [markdown]
# ## Parametrised Neurons voltage clamp experiment
# Now I can try to run the 5 neurons with multiple sweeps.

# %%
N = 5 # 5 Neurons
group = NeuronGroup(N, eqs_HH_Iind,
                    #threshold='v > -40*mV',
                    #refractory='v > -40*mV',
                    method='exponential_euler')

# Start the simulation at resting potential
group.v = -65*mV
group.I = 0*namp # start with no stimulation
# assign the conductances, here we systematically vary the Na conductance
group.dens_na = np.linspace(0.1,200,N)*msiemens*cm**-2
statemon = StateMonitor(group, ['I_Na', 'I_K', 'I_l'], record=True)

# %%
# store the initial state of the simulation
# do not add the statemonitor, as before. It will just record the equilibration step.
# that will then mess up the registering
groupnet = Network(group, statemon)
# run the simulation at RMP for a bit to equilibrate
groupnet.run(50*ms)
groupnet.store()

# %%
# run a loop to do multiple voltage clamp sweeps
V_stim = linspace(-80, 50, 10)*mV

tsresult = []       # container for the timeseries result
summaryresult = []  # container for the per-neuron summaries
# time for each sweep (ms)
runtime = 30
for V in V_stim:
    # restore the neurons 
    groupnet.restore()
    # set the new stimulation current and run
    group.v = V
    # run the neuron with monitor
    groupnet.run(runtime*ms)
    # tidy and save the time series results
    runresult = tidy_HHcurrents(statemon)
    runresult['sweep'] = [V/mV] * len(runresult['I_Na'])
    rowperneuron = int(len(runresult['I_Na'])/N) # this needs to an integer
    # add the sweep time
    runresult['t_stim'] = tile(np.linspace(0,runtime +50, rowperneuron), N) # need to add n neurons here
    tsresult.append(runresult)

# %%
# check whether it worked
pd.concat(tsresult)

# %%
# plot it all
# filter for the relevant time points
# melt and get the right timepoints
gNa_varieddf = pd.concat(tsresult)
gNa_varieddf = pd.melt(gNa_varieddf,
                      value_vars = ['I_l', 'I_Na', 'I_K', 'I_tot'],
                       id_vars = ['t', 'neuron', 'sweep']).query('t > 0.049 & t < 0.06')
# plot it
sns.relplot(data = gNa_varieddf,
            col = 'neuron',
            row = 'sweep',
            kind = 'line',
            hue = 'variable',
            x = 't',
            y = 'value')

# %%
# alternatively, plot all sweeps for each neuron but split by current
# filter out the boring stuff and plot just the vgated ones
sns.relplot(data = gNa_varieddf.query("t > 0.049 & t < 0.06 & (variable == 'I_Na' or variable == 'I_K')"),
            col = 'neuron',
            row = 'variable',
            kind = 'line',
            hue = 'sweep',
            x = 't',
            y = 'value')

# %% [markdown]
# # Current clamp experiments with repeated injections
# Here, I would like to repeatedly stimulate with short current pulses.
# This can then be used to construct I/O relationships.
#
# To do square pulse simulation, we can not start/stop the simulation for different values of `V` as we did for the voltage clamp.
# Instead, we can feed a time trajectory for a neuron parameter into the simulation.
# This is done with a brian object called [timed array](https://brian2.readthedocs.io/en/stable/user/input.html).
#
# A timed array takes a one or two dimensional array as its input.
# We can create such an array with a square pulse with [scipy.signal](https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.square.html)
#
# From the scipy doc:
#
# The square wave has a period $2\pi$, has value +1 from 0 to $2\pi\, {duty}$ and -1 from $2\pi\,{duty}$ to $2 \pi$. duty must be in the interval [0,1].

# %%
#define a time vector
t = np.linspace(0, 1, 500, endpoint=False)
# Make a square
square = signal.square(2 * np.pi * 10 * t, duty = 0.1)
plt.plot(t, square)
plt.ylim(-2, 2)


# %% [markdown]
# Based on the above we should be able to make a function that takes as an input:
# Desired width of the pulses (ms), frequency (hz) and the time length of output and sampling rate, and stimulus intensity.
#

# %%
def square_pulses(pulsewidth_ms, frequency_hz, tend_ms, SR_hz, Inj_nA):
    tarray_ms = np.linspace(0, tend_ms, int((tend_ms/1000)*SR_hz))
    
    # based on the desired pulsewidth we can determine the duty cycle
    d = (pulsewidth_ms/1000)*frequency_hz
    # create the pulse
    p = signal.square(2 * np.pi * frequency_hz * (tarray_ms/1000), duty = d)
    # scale to size
    p_scaled = ((p+1)/2*Inj_nA)
    # put into array
    pulse = np.vstack([tarray_ms, p_scaled])#.transpose()      
    return(p_scaled)


# %% jupyter={"outputs_hidden": true}
square_pulses(pulsewidth_ms = 0.1,
                      frequency_hz = 3,
                      tend_ms = 2000,
                      SR_hz = 2000,
                      Inj_nA = 3)



# %% [markdown]
# Check whether we can make a brian timedarray object from this.

# %%
TimedArray(square_pulses(pulsewidth_ms = 0.1,
                      frequency_hz = 300,
                      tend_ms = 2000,
                      SR_hz = 10,
                      Inj_nA = 3), dt = 1/2000*second)

# %% [markdown]
# To test this method, first set up a simple one neuron system to run.
# I am going to reassign everything again to not get confused as well as rejig the equations so everything is scaled to area.
# This is important for this kind of experiment because I would like to be able to retrieve the injections as current densities ($A/F$).

# %%
start_scope()
# re-assign the group
# reassign all the parameters to not get confused
# Parameters
area = 20000*umetre**2             # Membrane area
Cm = 1*ufarad*cm**-2                # capacitance per area
C = Cm *area
El = -65*mV                         # leak reversal (RMP)
EK = -90*mV                         # potassium reversal
ENa = 50*mV                         # sodium reversal

dens_na = 50*msiemens*cm**-2      # Na conductance per area
dens_kd = 30*msiemens*cm**-2       # K conductance per area 
dens_l = 5e-5*siemens*cm**-2       # leak conductance per area
g_na = dens_na*area
g_kd = dens_kd*area
g_l = dens_l*area

VT = -63*mV

# %%
# Setup the CC
CC = TimedArray(square_pulses(pulsewidth_ms = 0.01,
                      frequency_hz = 100,
                      tend_ms = 2000,
                      SR_hz = 20000,
                      Inj_nA = 10)*namp,
                dt = 1/20000*second)

# HH equation with separate channel variable
eqs_HH_area = '''
##### Ion channel currents
I_l = (g_na)*(v-El) :amp
I_Na = (g_kd)*(m*m*m)*h*(v-ENa) :amp
I_K = (g_l)*(n*n*n*n)*(v-EK) :amp

# Voltage equation
dv/dt = (g_l*(El-v) - (dens_na*area)*(m*m*m)*h*(v-ENa) - g_kd*(n*n*n*n)*(v-EK) + I + CC(t))/C : volt

##### Channel kinetics
# Na activation particle
dm/dt = 0.32*(mV**-1)*(13.*mV-v+VT)/
    (exp((13.*mV-v+VT)/(4.*mV))-1.)/ms*(1-m)-0.28*(mV**-1)*(v-VT-40.*mV)/
    (exp((v-VT-40.*mV)/(5.*mV))-1.)/ms*m : 1
    
# Na inactivation particle
dh/dt = 0.128*exp((17.*mV-v+VT)/(18.*mV))/ms*(1.-h)-4./(1+exp((40.*mV-v+VT)/(5.*mV)))/ms*h : 1
    
# K activation particle
dn/dt = 0.032*(mV**-1)*(15.*mV-v+VT)/
    (exp((15.*mV-v+VT)/(5.*mV))-1.)/ms*(1.-n)-.5*exp((10.*mV-v+VT)/(40.*mV))/ms*n : 1

# Current injection periodic
Ipulse = CC(t) :amp
##### Experimental parameters to set
# Current injection flat
I : amp (shared)
# Na channel density
dens_na: siemens*metre**-2 (shared)
C : farad
'''

# %% [markdown]
# I wanted to keep the formulationa s it was, with the currents assigned as separate variables then to be combined in the voltage equation.
# I don't know why, but it always gave an error!
# I put it all on one line and now it works.

# %%
# setup the neuron
N = 5
group = NeuronGroup(N, eqs_HH_area,
                    threshold='v > 0*mV',
                    refractory='v > 0*mV',
                    method='exponential_euler')

group.I = 0.00*namp # start with no stimulation
group.v = -64.8*mV # start with no stimulation
group.dens_na = 100*msiemens*cm**-2
group.C = np.linspace(1,30,N)* pfarad
statemon = StateMonitor(group, ['v', 'Ipulse'], record=True)
spikemon = SpikeMonitor(group)

# %%
run(2000*ms)
tidy_byN(group, spikemon)


# %%
# need a new tidier to get the CC and the Voltage data timeseries out
# Write the tidier
def tidy_CCv(monobjct):
    # Number of neurons
    n_neuron = monobjct.v.shape[0]
    # wide format with Neuron as column
    resultdf = pd.DataFrame(monobjct.v).transpose()
    # add time variable then melt by neuron
    resultdf['t'] = pd.Series(np.array(monobjct.t))
    resultdf = pd.melt(resultdf,
                   value_vars = list(range(0, n_neuron)),
                   id_vars = ['t'],
                   var_name = "neuron",
                   value_name = 'v')
    
    # create long dfs from the other variables
    Istim = pd.DataFrame(monobjct.Ipulse).transpose()
    Istim = pd.melt(Istim,
        value_vars = list(range(0, n_neuron)),
        var_name = "neuron",
        value_name = 'I_stim')['I_stim']
   
    # add the columns to the object
    resultdf = resultdf.assign(I_stim = Istim)
    return(resultdf)


# %% [markdown]
# This below shows that the timed array thing just does not input the pulses!.
# But why?

# %%
sns.relplot(data = tidy_CCv(statemon),
            x = 't',
            height = 2,
            kind = 'line',
            row = 'neuron',
            aspect = 8,
            y = 'I_stim')

# %% [markdown]
# Next, we want to get the response for this kind of stimuli.
# Because we have to put in the stimulation time in as the formula, there is no other way but to re-create the neuron in loops.
# This will increase the time it takes to calculate...
#
# Pseudo code:
#
# 1. For a list of frequencies,
# 2. iterate throungh a range of currents
# 3. In the loop, create a brian stimulus object with that combination
# 4. simulate it
# 5. write the results to an object

# %% [markdown]
# *After much fretting, I found the result to the problem above!
# The timed array only works, if the time and timestep exactly matches the length and timestep of the simulation!*
#
# The the code below that sets it up.

# %%
resultsfrqCC = []
resultsts = []

# this will result in a 50khz sampling rate//integration step
# which should be plenty to do the steps...
SR = 20000              #in hz
nsamples = (runtime/1000)*SR
deltat = 1/SR              #(in second)

# assign the parameters of the stimulation
freqoi = np.linspace(10,200,10, dtype = 'int')
ampoi = np.linspace(0.1,30,100)
pwidth = 0.2     #width for pulse generator
runtime = 500   #(ms) in time to run pulse generation and experi

# start the loop
for freq in freqoi:
    for stimamp in ampoi:
        # create the stimulus
        stim = square_pulses(pulsewidth_ms = pwidth,
                      frequency_hz = freq,
                      tend_ms = runtime,
                      SR_hz = SR,
                      Inj_nA = stimamp)
        CC = TimedArray(stim*namp, dt = deltat*second)        
        # create the neurons
        N = 5
        group = NeuronGroup(N, eqs_HH_area,
                           threshold='v > 0*mV',
                           refractory='v > 0*mV',
                           method='exponential_euler',
                           dt = deltat*second)        
        group.I = 0.00*namp # start with no stimulation
        group.v = -64.8*mV # start with no stimulation
        group.C = np.linspace(2,30, N) *pfarad
        group.dens_na = 100*msiemens*cm**-2
        #statemon = StateMonitor(group, ['v', 'Ipulse'], record=True)
        spikemon = SpikeMonitor(group)
        #run the simulation
        loopnet = Network(group,
                          #statemon,
                          spikemon)
        loopnet.run(runtime*ms)        
        # assign the results
        loopresult = tidy_byN(group, spikemon)
        loopresult['pulse_freq'] = [freq]*len(loopresult['v'])
        loopresult['pulse_amp'] = [stimamp]*len(loopresult['v'])
        loopresult['pulse_width'] = [pwidth]*len(loopresult['v'])
        # assign the timeseries
        #loopts = tidy_CCv(statemon)
        #loopts['pulse_freq'] = [freq]*len(loopts['v'])
        #loopts['pulse_amp'] = [stimamp]*len(loopts['v'])
        #loopts['pulse_width'] = [pwidth]*len(loopts['v'])
        # this is for debugging
        #loopts['stim_input'] = tile(stim,N)   
        
        resultsfrqCC.append(loopresult)
        #resultsts.append(loopts)
        

# %%
resultsfrqCC = pd.concat(resultsfrqCC)

# %%
resultsfrqCC

# %%
# how many spikes are produced for each stimulus?
# Does the neuron follow or fail to spike?
resultsfrqCC['stim_eff'] = resultsfrqCC['FRate_hz']/resultsfrqCC['pulse_freq']
# normalise stimulus to capacitance
# (this does not say so much because we have not scaled the channel densities to the capacitance)
resultsfrqCC['stim_dens'] = resultsfrqCC['pulse_amp']/resultsfrqCC['C']

# comparing the stimulus current density vs raw current is quite telling here and shows how that adjustment is necessary
# plot an injected current/Firing rate plot for every frequency, colour by neuron
sns.relplot(data = resultsfrqCC,
           col = 'pulse_freq',
           col_wrap = 5,
           x = 'stim_dens',
           y = 'stim_eff',
           hue = 'i', 
           kind = 'line')

# %% [markdown]
# The following will only work if in the previous run the timeseries objects had been created (that takes a lot of time).

# %%
resultsts = pd.concat(resultsts)

# %%
# plot the result of the timecourses for the same neuron and current to see whether there was a problem here
sns.relplot(data = resultsts.query('neuron == 4 and pulse_amp == 10'),
           x = 't',
           y = 'v',
             height = 2,
            aspect = 8,
           kind = 'line',
           row = 'pulse_freq',
           hue = 'neuron')

# %% [markdown]
# We have now established the basics, I will move the actual modelling to another directory and private github for obvious reasons.

# %%
